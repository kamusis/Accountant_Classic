# 性能卡顿与内存占用过高

<cite>
**本文档引用文件**   
- [Core.lua](file://Core/Core.lua)
- [CurrencyStorage.lua](file://CurrencyTracker/CurrencyStorage.lua)
- [Workspace-Memory-Dump.md](file://Docs/Workspace-Memory-Dump.md)
- [CurrencyEventHandler.lua](file://CurrencyTracker/CurrencyEventHandler.lua)
- [CurrencyDataManager.lua](file://CurrencyTracker/CurrencyDataManager.lua)
</cite>

## 目录
1. [引言](#引言)
2. [高频事件监听与性能瓶颈分析](#高频事件监听与性能瓶颈分析)
3. [货币数据存储结构与内存占用分析](#货币数据存储结构与内存占用分析)
4. [内存泄漏检测与分析方法](#内存泄漏检测与分析方法)
5. [性能优化建议](#性能优化建议)
6. [结论](#结论)

## 引言
Accountant_Classic 是一款用于追踪《魔兽世界》中金币与货币变化的插件，其核心功能包括金币追踪与货币追踪。随着功能的扩展，特别是货币追踪模块的引入，插件在运行时可能出现性能问题，如帧率下降、内存泄漏或事件处理延迟。本文档旨在深入分析 `Core.lua` 中高频事件（如 `UNIT_MONEY`）的监听频率与处理开销，评估是否因未节流导致性能瓶颈；同时检查 `CurrencyStorage.lua` 中的数据存储结构是否过于冗余，特别是在记录大量货币元数据时的内存占用情况。结合 `Workspace-Memory-Dump.md` 中的内存快照分析方法，为开发者提供识别对象泄漏点的指导，并提出具体的优化建议。

## 高频事件监听与性能瓶颈分析

`Core.lua` 模块作为插件的核心，负责初始化、事件注册和交易处理协调。该模块通过 AceEvent-3.0 库注册了大量与财务交易相关的事件，包括 `MERCHANT_SHOW`、`QUEST_TURNED_IN` 和 `PLAYER_MONEY` 等。事件处理的核心逻辑位于 `addon:OnEvent` 函数中。

当 `PLAYER_MONEY` 事件触发时，插件会执行 `updateLog()` 函数来记录交易。为了防止角色首次登录时的当前余额被错误地计为“收入”，插件实现了一种“基线初始化”（Priming Approach）策略。该策略通过一个持久化的标志位 `AC_LOG_PRIMED` 来确保基线初始化仅执行一次。一旦基线初始化完成，后续的金钱变化将被正常记录。

然而，`PLAYER_MONEY` 事件是一个高频事件，其触发频率与玩家的金钱变动直接相关。虽然代码中通过 `AC_LOG_PRIMED` 标志位避免了首次登录时的误判，但并未对事件处理本身进行节流（throttling）或去抖（debouncing）。这意味着每一次金钱变动都会立即触发一次完整的日志更新流程，包括数据存储和UI刷新，这在短时间内发生大量金钱变动时（例如拍卖行交易、任务奖励集中领取），可能会成为性能瓶颈，导致帧率下降。

此外，`CurrencyEventHandler.lua` 模块也注册了 `CURRENCY_DISPLAY_UPDATE` 事件来监听货币变化。该模块在 `OnCurrencyDisplayUpdate` 函数中实现了战斗状态检查，若玩家处于战斗中，则会将事件加入批处理队列（`AddToBatch`），待战斗结束后再统一处理，这实际上是一种延迟处理的优化。相比之下，`Core.lua` 中对 `PLAYER_MONEY` 事件的处理缺乏类似的批处理机制，所有处理都是即时的。

**Section sources**
- [Core.lua](file://Core/Core.lua#L1482-L1551)
- [CurrencyEventHandler.lua](file://CurrencyTracker/CurrencyEventHandler.lua#L542-L570)

## 货币数据存储结构与内存占用分析

`CurrencyStorage.lua` 模块负责管理货币数据的持久化存储，其数据结构设计对内存占用有直接影响。该模块将货币数据按多种时间周期（`Session`, `Day`, `Week`, `Month`, `Year`, `Total` 等）进行分桶存储。

对于每一种货币（由 `currencyID` 标识），其数据结构如下：
```lua
currencyData[currencyID] = {
    Session = { [source] = { In = 0, Out = 0 } },
    Day = { [source] = { In = 0, Out = 0 } },
    Week = { [source] = { In = 0, Out = 0 } },
    -- ... 其他时间周期
    Total = { [source] = { In = 0, Out = 0 } }
}
```
其中，`source` 是交易来源的标识符（如 `Unknown`, `BaselinePrime` 或具体的来源ID）。

这种设计的优点是查询效率高，可以快速按时间周期和来源进行统计。然而，其潜在的缺点是**冗余度高**。首先，对于每一种货币，都必须为所有时间周期初始化一个空表，即使该周期内没有数据。其次，对于每一条交易记录，都需要在 `In` 和 `Out` 两个字段中存储数据，尽管一次交易只能是收入或支出。更重要的是，`source` 字段的使用可能导致数据碎片化。如果来源种类繁多且动态变化，每个来源都会在每个时间周期的表中创建一个键值对，这会显著增加哈希表的开销。

此外，该模块还维护了 `currencyMeta` 表来记录原始事件元数据（gain/lost sources），用于分析和诊断。虽然这是一个可选功能，但如果开启，它会为每种货币的每个时间周期记录额外的计数信息，进一步增加了内存占用。

当玩家追踪大量货币（尤其是通过动态发现机制发现的货币）时，这种按货币ID和时间周期双重嵌套的结构会迅速消耗内存。例如，追踪100种货币，每种货币有10个时间周期，即使每个周期只有少量来源，其总的表结构开销也是相当可观的。

**Section sources**
- [CurrencyStorage.lua](file://CurrencyTracker/CurrencyStorage.lua#L568-L617)
- [CurrencyStorage.lua](file://CurrencyTracker/CurrencyStorage.lua#L661-L713)

## 内存泄漏检测与分析方法

`Workspace-Memory-Dump.md` 文档提供了一种内存快照分析方法，可用于识别对象泄漏点。该方法的核心思想是通过比较不同时间点的内存快照，找出持续增长且未被释放的对象。

具体到本插件，开发者可以采用以下步骤进行内存泄漏分析：
1.  **建立基线**：在游戏启动并加载插件后，立即获取一次内存快照。
2.  **执行操作**：进行一系列典型的、会触发插件逻辑的操作，例如：完成多个任务、进行多次拍卖行交易、打开和关闭货币追踪UI等。
3.  **获取快照**：在操作结束后，获取第二次内存快照。
4.  **对比分析**：使用内存分析工具对比两次快照，重点关注 `Accountant_ClassicSaveData` 这个全局表的增长情况。特别是检查 `currencyData` 和 `currencyMeta` 子表是否在没有合理理由的情况下持续增长。
5.  **识别泄漏点**：如果发现某些 `currencyID` 对应的数据在角色下线或插件禁用后仍未被清理，或者 `currencyMeta` 中的计数信息不断累积而没有重置机制，则可能存在内存泄漏。

此外，`CurrencyStorage.lua` 模块提供了 `GetStorageStats()` 函数，可以获取存储统计信息，包括追踪的货币数量和总交易数。开发者可以通过 `/ct` 命令行定期调用此函数，监控这些指标的变化趋势，作为内存占用的间接参考。

**Section sources**
- [Workspace-Memory-Dump.md](file://Docs/Workspace-Memory-Dump.md#L1-L80)
- [CurrencyStorage.lua](file://CurrencyTracker/CurrencyStorage.lua#L1181-L1221)

## 性能优化建议

基于上述分析，提出以下优化建议以缓解性能卡顿和内存占用过高的问题：

1.  **事件去抖（Debouncing）**：在 `Core.lua` 中，对 `PLAYER_MONEY` 事件的处理应引入去抖机制。可以借鉴 `CurrencyEventHandler.lua` 中对 `BAG_UPDATE` 事件的处理方式，使用 `C_Timer.NewTimer` 创建一个短暂的延迟（例如0.3秒）。当事件触发时，将其加入队列并启动计时器。如果在计时器结束前有新的 `PLAYER_MONEY` 事件到来，则重置计时器。这样可以将短时间内连续的金钱变动合并为一次处理，显著减少 `updateLog()` 的调用频率，从而降低CPU开销。

2.  **延迟初始化非关键模块**：`CurrencyTracker` 模块目前是“无头优先”（headless-first）设计，其UI模块（`CurrencyFrame`）默认是禁用的。这是一个很好的实践。建议进一步审查所有非核心功能模块（如高级诊断工具、可选的UI组件），确保它们仅在用户明确请求时才进行初始化和加载，避免在插件启动时加载不必要的代码和数据，减少初始内存占用和启动时间。

3.  **定期清理过期数据**：`CurrencyStorage.lua` 中的 `ShiftCurrencyLogs` 函数已经实现了按时间周期滚动日志的逻辑（如将 `Day` 数据移至 `PrvDay`）。建议增加一个更彻底的清理机制，例如，在角色登出或插件禁用时，自动清理 `Session` 周期的所有数据。同时，可以考虑为 `PrvDay`, `PrvWeek` 等历史数据设置一个保留期限（如保留最近30天），超出期限的数据应被自动删除，以防止 `SavedVariables` 文件无限增长。

4.  **关闭不必要的增强跟踪选项**：文档中提到的 `currencyMeta` 元数据记录功能，虽然对调试很有帮助，但会增加内存和存储开销。建议将此功能设为可选，并默认关闭。用户可以在需要诊断问题时手动开启，问题解决后及时关闭，以保持运行时的轻量化。

5.  **优化数据结构**：可以考虑重构 `CurrencyStorage` 的数据结构，例如，将 `In` 和 `Out` 合并为一个带符号的 `Amount` 字段，或者对来源（`source`）进行更严格的预定义和归类，避免因来源过多导致的哈希表碎片化。

**Section sources**
- [CurrencyEventHandler.lua](file://CurrencyTracker/CurrencyEventHandler.lua#L511-L547)
- [CurrencyStorage.lua](file://CurrencyTracker/CurrencyStorage.lua#L256-L290)

## 结论
Accountant_Classic 插件在处理高频金钱事件时缺乏节流机制，且其货币数据存储结构存在一定的冗余性，这两点是导致潜在性能问题的主要原因。通过实施事件去抖、延迟初始化、定期清理和关闭非必要功能等优化措施，可以有效缓解帧率下降和内存占用过高的问题。开发者应利用内存快照分析方法，持续监控插件的内存使用情况，确保其在长期运行中的稳定性和高效性。